#include "RHIResourceLayout.h"

#include <Vex/Bindings.h>
#include <Vex/Containers/ResourceCleanup.h>
#include <Vex/Logger.h>
#include <Vex/PhysicalDevice.h>
#include <Vex/RHIBindings.h>
#include <Vex/RHIImpl/RHI.h>
#include <Vex/RHIImpl/RHIPipelineState.h>
#include <Vex/RHIImpl/RHITexture.h>

namespace vex
{

RHIResourceLayoutBase::RHIResourceLayoutBase()
    : maxLocalConstantsByteSize(GPhysicalDevice->featureChecker->GetMaxLocalConstantsByteSize())
    , localConstantsData(maxLocalConstantsByteSize)
{
}

RHIResourceLayoutBase::~RHIResourceLayoutBase() = default;

void RHIResourceLayoutBase::SetLayoutResources(RHI& rhi,
                                               ResourceCleanup& resourceCleanup,
                                               std::span<const ConstantBinding> constants,
                                               std::span<RHITextureBinding> textures,
                                               std::span<RHIBufferBinding> buffers,
                                               RHIDescriptorPool& descriptorPool)
{
    // Remove and mark for deletion the previous buffer (if any)
    if (currentInternalConstantBuffer)
    {
        resourceCleanup.CleanupResource(std::move(currentInternalConstantBuffer));
        currentInternalConstantBuffer = std::nullopt;
    }

    localConstantsData.resize(maxLocalConstantsByteSize);
#if !VEX_SHIPPING
    // Fill the buffer with FF to mark as garbage.
    std::fill(localConstantsData.begin(), localConstantsData.end(), 0xFF);
#endif

    u32 currentlyUsedBytes = ConstantBinding::ConcatConstantBindings(constants, localConstantsData);
    localConstantsData.resize(currentlyUsedBytes);

    std::vector<u32> bindlessHandles;
    // Allocate for worst-case scenario.
    bindlessHandles.reserve(textures.size() + buffers.size());
    for (auto& [binding, texture] : textures)
    {
        bindlessHandles.push_back(texture->GetOrCreateBindlessView(binding, static_cast<TextureUsage::Type>(binding.usage), descriptorPool).GetIndex());
    }

    for (auto& [binding, buffer] : buffers)
    {
        bindlessHandles.push_back(
            buffer->GetOrCreateBindlessView(binding.usage, binding.stride, descriptorPool).GetIndex());
    }

    // Tmp buffer for uploading the bindless constants.. this doesn't scale well...
    // Ideally we'd allocate a BAB (big-ass-buffer) and then use subsections in it (or even better, have an allocation
    // strategy that allocates huge chunks of memory and create as many buffers as we want in it).
    // Instead we just greedily allocate buffers for now.
    if (!bindlessHandles.empty())
    {
        currentInternalConstantBuffer =
            rhi.CreateBuffer(BufferDescription{ .name = "VexAutogeneratedBindlessBuffer",
                                                .byteSize = static_cast<u32>(bindlessHandles.size() * sizeof(u32)),
                                                .usage = BufferUsage::UniformBuffer,
                                                .memoryLocality = ResourceMemoryLocality::CPUWrite });
        currentInternalConstantBuffer->GetMappedMemory().SetData(
            std::span<u8>{ reinterpret_cast<u8*>(bindlessHandles.data()), bindlessHandles.size() * sizeof(u32) });
    }
}

void RHIResourceLayoutBase::SetSamplers(std::span<TextureSampler> newSamplers)
{
    // Validation of the sampler name.
    for (auto& s : newSamplers)
    {
        if (s.name.empty())
        {
            VEX_LOG(Fatal,
                    "Your sampler state must have a valid name, otherwise you cannot use the sampler in shaders!");
        }
    }

    samplers = { newSamplers.begin(), newSamplers.end() };
    isDirty = true;
}

std::span<const TextureSampler> RHIResourceLayoutBase::GetStaticSamplers() const
{
    return samplers;
}

std::span<const u8> RHIResourceLayoutBase::GetLocalConstantsData() const
{
    return localConstantsData;
}

} // namespace vex